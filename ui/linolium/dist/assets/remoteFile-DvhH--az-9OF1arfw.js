import{Q as f}from"./taxonium-component.es-D8UFPkMd.js";import{aF as u}from"./JBrowsePanel-CjeUdi3D-Dhrr89W5.js";var w=u();const m=f(w);function c(i){return(typeof i=="object"&&i!==null&&"message"in i?i.message:`${i}`).replace(/\.$/,"")}class y{constructor(t,e={}){this.baseOverrides={},this.url=t;const s=e.fetch||globalThis.fetch.bind(globalThis);e.overrides&&(this.baseOverrides=e.overrides),this.fetchImplementation=s}async fetch(t,e){let s;try{s=await this.fetchImplementation(t,e)}catch(a){if(`${a}`.includes("Failed to fetch")){console.warn(`generic-filehandle: refetching ${t} to attempt to work around chrome CORS header caching bug`);try{s=await this.fetchImplementation(t,{...e,cache:"reload"})}catch(n){throw new Error(`${c(n)} fetching ${t}`,{cause:n})}}else throw new Error(`${c(a)} fetching ${t}`,{cause:a})}return s}async read(t,e,s={}){const{headers:a={},signal:n,overrides:o={}}=s;t<1/0?a.range=`bytes=${e}-${e+t}`:t===1/0&&e!==0&&(a.range=`bytes=${e}-`);const r=await this.fetch(this.url,{...this.baseOverrides,...o,headers:{...a,...o.headers,...this.baseOverrides.headers},method:"GET",redirect:"follow",mode:"cors",signal:n});if(!r.ok)throw new Error(`HTTP ${r.status} fetching ${this.url}`);if(r.status===200&&e===0||r.status===206){const l=await r.arrayBuffer(),d=r.headers.get("content-range"),h=/\/(\d+)$/.exec(d||"");return h!=null&&h[1]&&(this._stat={size:parseInt(h[1],10)}),new Uint8Array(l.slice(0,t))}throw r.status===200?new Error(`${this.url} fetch returned status 200, expected 206`):new Error(`HTTP ${r.status} fetching ${this.url}`)}async readFile(t={}){let e,s;typeof t=="string"?(e=t,s={}):(e=t.encoding,s=t,delete s.encoding);const{headers:a={},signal:n,overrides:o={}}=s,r=await this.fetch(this.url,{headers:a,method:"GET",redirect:"follow",mode:"cors",signal:n,...this.baseOverrides,...o});if(r.status!==200)throw new Error(`HTTP ${r.status} fetching ${this.url}`);if(e==="utf8")return r.text();if(e)throw new Error(`unsupported encoding: ${e}`);return new Uint8Array(await r.arrayBuffer())}async stat(){if(!this._stat&&(await this.read(10,0),!this._stat))throw new Error(`unable to determine size of file at ${this.url}`);return this._stat}async close(){}}export{m as $,y};
