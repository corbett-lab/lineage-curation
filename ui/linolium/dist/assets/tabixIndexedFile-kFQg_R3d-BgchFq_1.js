import{c as G}from"./AbortablePromiseCache-CcuMrnn7-56xRj2xE.js";import{x as M,_ as Q}from"./unzip-CwWdnRSo-02Ze3MCz.js";import{r as q}from"./browser-BpRiKmO--zAOSyNoU.js";import{y as D,$ as X}from"./remoteFile-DvhH--az-9OF1arfw.js";class F{constructor(e,t,n,i=void 0){this.minv=e,this.maxv=t,this.bin=n,this._fetchedSize=i}toUniqueString(){return`${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`}toString(){return this.toUniqueString()}compareTo(e){return this.minv.compareTo(e.minv)||this.maxv.compareTo(e.maxv)||this.bin-e.bin}fetchedSize(){return this._fetchedSize!==void 0?this._fetchedSize:this.maxv.blockPosition+65536-this.minv.blockPosition}}class H{constructor({filehandle:e,renameRefSeqs:t=n=>n}){this.filehandle=e,this.renameRefSeq=t}async getMetadata(e={}){const{indices:t,...n}=await this.parse(e);return n}_findFirstData(e,t){return e?e.compareTo(t)>0?t:e:t}async parse(e={}){return this.parseP||(this.parseP=this._parse(e).catch(t=>{throw this.parseP=void 0,t})),this.parseP}async hasRefSeq(e,t={}){var n;return!!((n=(await this.parse(t)).indices[e])!=null&&n.binIndex)}}const L=65536,J=L*L;function W(s,e=0){const t=s[e]|s[e+1]<<8|s[e+2]<<16|s[e+3]<<24;return((s[e+4]|s[e+5]<<8|s[e+6]<<16|s[e+7]<<24)>>>0)*J+(t>>>0)}class K extends Error{}function R(s){if(s&&s.aborted){if(typeof DOMException<"u")throw new DOMException("aborted","AbortError");{const e=new K("aborted");throw e.code="ERR_ABORTED",e}}}function Z(s,e){return e.minv.blockPosition-s.maxv.blockPosition<65e3&&e.maxv.blockPosition-s.minv.blockPosition<5e6}function Y(s,e){const t=[];let n=null;return s.length===0?s:(s.sort(function(i,a){const o=i.minv.blockPosition-a.minv.blockPosition;return o!==0?o:i.minv.dataPosition-a.minv.dataPosition}),s.forEach(i=>{(!e||i.maxv.compareTo(e)>0)&&(n===null?(t.push(i),n=i):Z(n,i)?i.maxv.compareTo(n.maxv)>0&&(n.maxv=i.maxv):(t.push(i),n=i))}),t)}class U{constructor(e,t){this.blockPosition=e,this.dataPosition=t}toString(){return`${this.blockPosition}:${this.dataPosition}`}compareTo(e){return this.blockPosition-e.blockPosition||this.dataPosition-e.dataPosition}}function S(s,e=0){return new U(s[e+7]*1099511627776+s[e+6]*4294967296+s[e+5]*16777216+s[e+4]*65536+s[e+3]*256+s[e+2],s[e+1]<<8|s[e])}const ee=21582659,te=38359875,ne={0:"generic",1:"SAM",2:"VCF"};function ie(s,e){return s*2**e}function V(s,e){return Math.floor(s/2**e)}class z extends H{constructor(e){super(e),this.maxBinNumber=0,this.depth=0,this.minShift=0}async lineCount(e,t={}){const n=await this.parse(t),i=n.refNameToId[e];if(i===void 0||!n.indices[i])return-1;const{stats:a}=n.indices[i];return a?a.lineCount:-1}indexCov(){throw new Error("CSI indexes do not support indexcov")}parseAuxData(e,t){const n=new DataView(e.buffer),i=n.getInt32(t,!0),a=i&65536?"zero-based-half-open":"1-based-closed",o=ne[i&15];if(!o)throw new Error(`invalid Tabix preset format flags ${i}`);const r={ref:n.getInt32(t+4,!0),start:n.getInt32(t+8,!0),end:n.getInt32(t+12,!0)},c=n.getInt32(t+16,!0),u=c?String.fromCharCode(c):null,l=n.getInt32(t+20,!0),h=n.getInt32(t+24,!0),{refIdToName:d,refNameToId:g}=this._parseNameBytes(e.subarray(t+28,t+28+h));return{refIdToName:d,refNameToId:g,skipLines:l,metaChar:u,columnNumbers:r,format:o,coordinateType:a}}_parseNameBytes(e){let t=0,n=0;const i=[],a={},o=new TextDecoder("utf8");for(let r=0;r<e.length;r+=1)if(!e[r]){if(n<r){const c=this.renameRefSeq(o.decode(e.subarray(n,r)));i[t]=c,a[c]=t}n=r+1,t+=1}return{refNameToId:a,refIdToName:i}}async _parse(e={}){const t=await M(await this.filehandle.readFile(e)),n=new DataView(t.buffer);let i;if(n.getUint32(0,!0)===ee)i=1;else if(n.getUint32(0,!0)===te)i=2;else throw new Error("Not a CSI file");this.minShift=n.getInt32(4,!0),this.depth=n.getInt32(8,!0),this.maxBinNumber=((1<<(this.depth+1)*3)-1)/7;const a=2**(this.minShift+this.depth*3),o=n.getInt32(12,!0),r=o&&o>=30?this.parseAuxData(t,16):{refIdToName:[],refNameToId:{},metaChar:null,columnNumbers:{ref:0,start:1,end:2},coordinateType:"zero-based-half-open",format:"generic"},c=n.getInt32(16+o,!0);let u,l=16+o+4;const h=new Array(c).fill(0).map(()=>{const d=n.getInt32(l,!0);l+=4;const g={};let p;for(let w=0;w<d;w+=1){const b=n.getUint32(l,!0);if(b>this.maxBinNumber)p=this.parsePseudoBin(t,l+4),l+=48;else{const m=S(t,l+4);u=this._findFirstData(u,m);const x=n.getInt32(l+12,!0);l+=16;const f=new Array(x);for(let v=0;v<x;v+=1){const y=S(t,l),I=S(t,l+8);l+=16,f[v]=new F(y,I,b)}g[b]=f}}return{binIndex:g,stats:p}});return{...r,csi:!0,refCount:c,maxBlockSize:65536,firstDataLine:u,csiVersion:i,indices:h,depth:this.depth,maxBinNumber:this.maxBinNumber,maxRefLength:a}}parsePseudoBin(e,t){return{lineCount:W(e,t+28)}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const a=await this.parse(i),o=a.refNameToId[e];if(o===void 0)return[];const r=a.indices[o];if(!r)return[];const c=this.reg2bins(t,n),u=[];for(const[l,h]of c)for(let d=l;d<=h;d++)if(r.binIndex[d])for(const g of r.binIndex[d])u.push(new F(g.minv,g.maxv,d));return Y(u,new U(0,0))}reg2bins(e,t){e-=1,e<1&&(e=1),t>2**50&&(t=2**34),t-=1;let n=0,i=0,a=this.minShift+this.depth*3;const o=[];for(;n<=this.depth;a-=3,i+=ie(1,n*3),n+=1){const r=i+V(e,a),c=i+V(t,a);if(c-r+o.length>this.maxBinNumber)throw new Error(`query ${e}-${t} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);o.push([r,c])}return o}}const re=21578324,O=14;function ae(s,e){return s+=1,e-=1,[[0,0],[1+(s>>26),1+(e>>26)],[9+(s>>23),9+(e>>23)],[73+(s>>20),73+(e>>20)],[585+(s>>17),585+(e>>17)],[4681+(s>>14),4681+(e>>14)]]}class k extends H{async lineCount(e,t={}){var n;const i=await this.parse(t),a=i.refNameToId[e];return a===void 0||!i.indices[a]?-1:((n=i.indices[a].stats)==null?void 0:n.lineCount)??-1}async _parse(e={}){const t=await this.filehandle.readFile(e),n=await M(t);R(e.signal);const i=new DataView(n.buffer);if(i.getUint32(0,!0)!==re)throw new Error("Not a TBI file");const a=i.getUint32(4,!0),o=i.getUint32(8,!0),r=o&65536?"zero-based-half-open":"1-based-closed",c={0:"generic",1:"SAM",2:"VCF"}[o&15];if(!c)throw new Error(`invalid Tabix preset format flags ${o}`);const u={ref:i.getInt32(12,!0),start:i.getInt32(16,!0),end:i.getInt32(20,!0)},l=i.getInt32(24,!0),h=5,d=((1<<(h+1)*3)-1)/7,g=2**(14+h*3),p=l?String.fromCharCode(l):null,w=i.getInt32(28,!0),b=i.getInt32(32,!0),{refNameToId:m,refIdToName:x}=this._parseNameBytes(n.slice(36,36+b));let f=36+b,v;return{indices:new Array(a).fill(0).map(()=>{const y=i.getInt32(f,!0);f+=4;const I={};let C;for(let T=0;T<y;T+=1){const E=i.getUint32(f,!0);if(f+=4,E>d+1)throw new Error("tabix index contains too many bins, please use a CSI index");if(E===d+1){const P=i.getInt32(f,!0);f+=4,P===2&&(C=this.parsePseudoBin(n,f)),f+=16*P}else{const P=i.getInt32(f,!0);f+=4;const A=new Array(P);for(let _=0;_<P;_+=1){const $=S(n,f),j=S(n,f+8);f+=16,v=this._findFirstData(v,$),A[_]=new F($,j,E)}I[E]=A}}const B=i.getInt32(f,!0);f+=4;const N=new Array(B);for(let T=0;T<B;T+=1)N[T]=S(n,f),f+=8,v=this._findFirstData(v,N[T]);return{binIndex:I,linearIndex:N,stats:C}}),metaChar:p,maxBinNumber:d,maxRefLength:g,skipLines:w,firstDataLine:v,columnNumbers:u,coordinateType:r,format:c,refIdToName:x,refNameToId:m,maxBlockSize:65536}}parsePseudoBin(e,t){return{lineCount:W(e,t+16)}}_parseNameBytes(e){let t=0,n=0;const i=[],a={},o=new TextDecoder("utf8");for(let r=0;r<e.length;r+=1)if(!e[r]){if(n<r){const c=this.renameRefSeq(o.decode(e.subarray(n,r)));i[t]=c,a[c]=t}n=r+1,t+=1}return{refNameToId:a,refIdToName:i}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const a=await this.parse(i),o=a.refNameToId[e];if(o===void 0)return[];const r=a.indices[o];if(!r)return[];(r.linearIndex.length?r.linearIndex[t>>O>=r.linearIndex.length?r.linearIndex.length-1:t>>O]:new U(0,0))||console.warn("querying outside of possible tabix range");const c=ae(t,n),u=[];for(const[p,w]of c)for(let b=p;b<=w;b++)if(r.binIndex[b])for(const m of r.binIndex[b])u.push(new F(m.minv,m.maxv,b));const l=r.linearIndex.length;let h=null;const d=Math.min(t>>14,l-1),g=Math.min(n>>14,l-1);for(let p=d;p<=g;++p){const w=r.linearIndex[p];w&&(!h||w.compareTo(h)<0)&&(h=w)}return Y(u,h)}}function se(s){return/^[\u0000-\u007F]*$/.test(s)}class he{constructor({path:e,filehandle:t,url:n,tbiPath:i,tbiUrl:a,tbiFilehandle:o,csiPath:r,csiUrl:c,csiFilehandle:u,renameRefSeqs:l=d=>d,chunkCacheSize:h=5*2**20}){if(t)this.filehandle=t;else if(e)this.filehandle=new q(e);else if(n)this.filehandle=new D(n);else throw new TypeError("must provide either filehandle or path");if(o)this.index=new k({filehandle:o,renameRefSeqs:l});else if(u)this.index=new z({filehandle:u,renameRefSeqs:l});else if(i)this.index=new k({filehandle:new q(i),renameRefSeqs:l});else if(r)this.index=new z({filehandle:new q(r),renameRefSeqs:l});else if(e)this.index=new k({filehandle:new q(`${e}.tbi`),renameRefSeqs:l});else if(c)this.index=new z({filehandle:new D(c)});else if(a)this.index=new k({filehandle:new D(a)});else if(n)this.index=new k({filehandle:new D(`${n}.tbi`)});else throw new TypeError("must provide one of tbiFilehandle, tbiPath, csiFilehandle, csiPath, tbiUrl, csiUrl");this.renameRefSeq=l,this.chunkCache=new G({cache:new X({maxSize:Math.floor(h/65536)}),fill:(d,g)=>this.readChunk(d,{signal:g})})}async getLines(e,t,n,i){let a,o={},r;typeof i=="function"?r=i:(o=i,r=i.lineCallback,a=i.signal);const c=await this.index.getMetadata(o);R(a);const u=t??0,l=n??c.maxRefLength;if(!(u<=l))throw new TypeError("invalid start and end coordinates. start must be less than or equal to end");if(u===l)return;const h=await this.index.blocksForRange(e,u,l,o);R(a);const d=new TextDecoder("utf8");for(const g of h){const{buffer:p,cpositions:w,dpositions:b}=await this.chunkCache.get(g.toString(),g,a);R(a);let m=0,x=0;const f=d.decode(p),v=se(f);for(;m<f.length;){let y,I;if(v){if(I=f.indexOf(`
`,m),I===-1)break;y=f.slice(m,I)}else{if(I=p.indexOf(10,m),I===-1)break;const N=p.slice(m,I);y=d.decode(N)}if(b){for(;m+g.minv.dataPosition>=b[x++];);x--}const{startCoordinate:C,overlaps:B}=this.checkLine(c,e,u,l,y);if(B)r(y,w[x]*256+(m-b[x])+g.minv.dataPosition+1);else if(C!==void 0&&C>=l)return;m=I+1}}}async getMetadata(e={}){return this.index.getMetadata(e)}async getHeaderBuffer(e={}){const{firstDataLine:t,metaChar:n,maxBlockSize:i}=await this.getMetadata(e);R(e.signal);const a=((t==null?void 0:t.blockPosition)||0)+i,o=await this.filehandle.read(a,0,e),r=await M(o);if(n){let c=-1;const u=10,l=n.charCodeAt(0);for(let h=0;h<r.length&&!(h===c+1&&r[h]!==l);h+=1)r[h]===u&&(c=h);return r.subarray(0,c+1)}return r}async getHeader(e={}){const t=new TextDecoder("utf8"),n=await this.getHeaderBuffer(e);return t.decode(n)}async getReferenceSequenceNames(e={}){return(await this.getMetadata(e)).refIdToName}checkLine(e,t,n,i,a){const{columnNumbers:o,metaChar:r,coordinateType:c,format:u}=e;if(r&&a.startsWith(r))return{overlaps:!1};let{ref:l,start:h,end:d}=o;l||(l=0),h||(h=0),d||(d=0),u==="VCF"&&(d=8);const g=Math.max(l,h,d);let p=1,w=0,b="",m=-1/0;const x=a.length;for(let f=0;f<x+1;f++)if(a[f]==="	"||f===x){if(p===l){if(this.renameRefSeq(a.slice(w,f))!==t)return{overlaps:!1}}else if(p===h){if(m=parseInt(a.slice(w,f),10),c==="1-based-closed"&&(m-=1),m>=i)return{startCoordinate:m,overlaps:!1};if((d===0||d===h)&&m+1<=n)return{startCoordinate:m,overlaps:!1}}else if(u==="VCF"&&p===4)b=a.slice(w,f);else if(p===d&&(u==="VCF"?this._getVcfEnd(m,b,a.slice(w,f)):Number.parseInt(a.slice(w,f),10))<=n)return{overlaps:!1};if(w=f+1,p+=1,p>g)break}return{startCoordinate:m,overlaps:!0}}_getVcfEnd(e,t,n){let i=e+t.length;const a=n.includes("SVTYPE=TRA");if(n[0]!=="."&&!a){let o=";";for(let r=0;r<n.length;r+=1){if(o===";"&&n.slice(r,r+4)==="END="){let c=n.indexOf(";",r);c===-1&&(c=n.length),i=parseInt(n.slice(r+4,c),10);break}o=n[r]}}else if(a)return e+1;return i}async lineCount(e,t={}){return this.index.lineCount(e,t)}async readChunk(e,t={}){const n=await this.filehandle.read(e.fetchedSize(),e.minv.blockPosition,t);return Q(n,e)}}export{he as m};
