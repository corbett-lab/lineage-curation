import{f as N}from"./main-D1zX1xg0-CI_PM91Q.js";import{e as D}from"./index-Bp4pXTEU-Cipcrd2k.js";import{u as w,a1 as $}from"./JBrowsePanel-CjeUdi3D-Dhrr89W5.js";import{o as j}from"./rxjs-euq-mp90-DvajfGj-.js";import"./index-Bwk-R6QR.js";import"./taxonium-component.es-D8UFPkMd.js";const x=new Set(["DUP","TRA","INV","CNV","DEL"]);function v(u,a,t,r){const e=u.split("	"),l=e[t?3:0],i=+e[t?4:1],n=+e[t?5:2],c=e[t?0:3],o=+e[t?1:4],h=+e[t?2:5],d=e[6],s=+e[7],f=g(e[8]),T=g(e[9]),p=e.slice(10),b=r?Object.fromEntries(r.slice(10).map((y,F)=>[y,p[F]])):{},m=x.has(p[0])?`<${p[0]}>`:void 0;return new w.SimpleFeature({...b,start:i,end:n,type:"paired_feature",refName:l,strand:f,name:d,score:s,uniqueId:a,mate:{refName:c,start:o,end:h,strand:T},...m?{ALT:[m]}:{}})}function g(u){return u==="+"?1:u==="-"?-1:u==="."?0:void 0}class P extends D.BaseFeatureDataAdapter{constructor(){super(...arguments),this.intervalTrees={}}async loadDataP(a){const t=(await w.fetchAndMaybeUnzipText($.openLocation(this.getConf("bedpeLocation"),this.pluginManager),a)).split(/\n|\r\n|\r/).filter(o=>!!o),r=[];let e=0;for(;e<t.length&&t[e].startsWith("#");e++)r.push(t[e]);const l=r.join(`
`),i={},n={};for(;e<t.length;e++){const o=t[e],h=o.split("	"),d=h[0],s=h[3];i[d]||(i[d]=[]),n[s]||(n[s]=[]),i[d].push(o),n[s].push(o)}const c=this.getConf("columnNames");return{header:l,feats1:i,feats2:n,columnNames:c}}async loadData(a={}){return this.bedpeFeatures||(this.bedpeFeatures=this.loadDataP(a).catch(t=>{throw this.bedpeFeatures=void 0,t})),this.bedpeFeatures}async getRefNames(a={}){const{feats1:t,feats2:r}=await this.loadData(a);return[...new Set([...Object.keys(t),...Object.keys(r)])]}async getHeader(a={}){const{header:t}=await this.loadData(a);return t}async getNames(){const{header:a,columnNames:t}=await this.loadData();if(t.length)return t;const r=a.split(/\n|\r\n|\r/).filter(e=>!!e).at(-1);return r!=null&&r.includes("	")?r.slice(1).split("	").map(e=>e.trim()):void 0}async loadFeatureTreeP(a){var t,r,e,l;const{feats1:i,feats2:n}=await this.loadData(),c=await this.getNames(),o=new N,h=(r=(t=i[a])===null||t===void 0?void 0:t.map((s,f)=>v(s,`${this.id}-${a}-${f}-r1`,!1,c)))!==null&&r!==void 0?r:[],d=(l=(e=n[a])===null||e===void 0?void 0:e.map((s,f)=>v(s,`${this.id}-${a}-${f}-r2`,!0,c)))!==null&&l!==void 0?l:[];for(const s of[...h,...d])o.insert([s.get("start"),s.get("end")],s);return o}async loadFeatureTree(a){return this.intervalTrees[a]||(this.intervalTrees[a]=this.loadFeatureTreeP(a).catch(t=>{throw this.intervalTrees[a]=void 0,t})),this.intervalTrees[a]}getFeatures(a,t={}){return j.ObservableCreate(async r=>{const{start:e,end:l,refName:i}=a,n=await this.loadFeatureTree(i);for(const c of(n==null?void 0:n.search([e,l]))||[])r.next(c);r.complete()},t.stopToken)}}P.capabilities=["getFeatures","getRefNames"];export{P as default};
