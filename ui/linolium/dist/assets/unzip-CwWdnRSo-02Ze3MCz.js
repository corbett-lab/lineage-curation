import{c as g}from"./index-CJFOLICt-oWu2Snlz.js";function P(r){let t=0;for(const n of r)t+=n.length;return t}function d(r){const t=new Uint8Array(P(r));let n=0;for(const o of r)t.set(o,n),n+=o.length;return t}const{Z_SYNC_FLUSH:f,Inflate:k}=g;async function x(r){try{let t,n=0,o;const i=[];do{const s=r.subarray(n);if(o=new k,{strm:t}=o,o.push(s,f),o.err)throw new Error(o.msg);n+=t.next_in,i.push(o.result)}while(t.avail_in);return d(i)}catch(t){throw/incorrect header check/.exec(`${t}`)?new Error("problem decompressing block: incorrect gzip header check"):t}}async function _(r,t){try{let n;const{minv:o,maxv:i}=t;let s=o.blockPosition,a=o.dataPosition;const e=[],h=[],l=[];let u=0;do{const m=r.subarray(s-o.blockPosition),c=new k;if({strm:n}=c,c.push(m,f),c.err)throw new Error(c.msg);const p=c.result;e.push(p);let b=p.length;h.push(s),l.push(a),e.length===1&&o.dataPosition&&(e[0]=e[0].subarray(o.dataPosition),b=e[0].length);const w=s;if(s+=n.next_in,a+=b,w>=i.blockPosition){e[u]=e[u].subarray(0,i.blockPosition===o.blockPosition?i.dataPosition-o.dataPosition+1:i.dataPosition+1),h.push(s),l.push(a);break}u++}while(n.avail_in);return{buffer:d(e),cpositions:h,dpositions:l}}catch(n){throw/incorrect header check/.exec(`${n}`)?new Error("problem decompressing block: incorrect gzip header check"):n}}export{_,d as b,x};
