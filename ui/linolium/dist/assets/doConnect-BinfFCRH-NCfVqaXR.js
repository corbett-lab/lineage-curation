import{u as y,s as w,a1 as U,bQ as O,t as W}from"./JBrowsePanel-CjeUdi3D-Dhrr89W5.js";import"./index-Bwk-R6QR.js";import"./taxonium-component.es-D8UFPkMd.js";class k{constructor(t=[],c){this.data={};const{checkIndent:s=!0,skipValidation:l=!1}=c??{},o=typeof t=="string"?t.trimEnd().split(/\r?\n/):t;let i,e;for(const d of o){if(d==="")throw new Error("Invalid stanza, contained blank lines");if(d.trim().startsWith("#"))continue;if(d.trimEnd().endsWith("\\")){const f=d.trimEnd().slice(0,-1);e?e+=f.trimStart():e=f;continue}let m=d;if(e&&(m=e+m.trimStart(),e=void 0),i??s){const f=/^([ \t]+)/.exec(m);if(i===void 0)f?[,i]=f:i="";else if(i===""&&f!==null||i&&f&&i!==f[1])throw new Error("Inconsistent indentation of stanza")}else i="";const a=m.trim(),h=a.indexOf(" ");if(h===-1){if(!this.nameKey)throw new Error("First line in a stanza must have both a key and a value");if(this.data[a])continue;this.data[a]="";continue}const r=a.slice(0,h),u=a.slice(h+1);if(this.data[r]&&u!==this.data[r])throw new Error(`Got duplicate key with a different value in stanza: "${r}" key has both ${this.data[r]} and ${u}`);this.nameKey||(this.nameKey=r,this.name=a.slice(h+1)),this.data[r]=u}l||this.validate()}validate(){}}class q{constructor(t=[],c){this.data={};const{checkIndent:s=!0,skipValidation:l=!1}=c??{},o=typeof t=="string"?t.trimEnd().split(/(?:[\t ]*\r?\n){2,}/):t;for(const i of o){if(i==="")throw new Error("Invalid stanza, was empty");if(i.startsWith("include")||i.trim().startsWith("#")&&i.trimEnd().split(/\r?\n/).map(d=>d.trim()).every(d=>d.startsWith("#")))continue;const e=new k(i,{checkIndent:s});if(!this.nameKey)this.nameKey=e.nameKey;else if(e.nameKey!==this.nameKey)throw new Error(`The first line in each stanza must have the same key. Saw both ${this.nameKey} and ${e.nameKey}`);if(!e.name)throw new Error(`No stanza name: ${e.name}`);if(this.data[e.name])throw new Error(`Got duplicate stanza name: ${e.name}`);this.data[e.name]=e}l||this.validate()}validate(){}}function L(n,t,c=""){const s=[];for(const l of t)n.data[l]||s.push(l);if(s.length>0)throw new Error(`${c} is missing required entr${s.length===1?"y":"ies"}: ${s.join(", ")}`)}class B extends q{constructor(t,c){super(t,{...c,checkIndent:!1})}validate(){var t;if(this.nameKey!=="track")throw new Error(`trackDb has "${this.nameKey}" instead of "track" as the first line in each track`);for(const[c,s]of Object.entries(this.data)){const l=Object.keys(s.data);L(s,["track","shortLabel"],`Track ${c}`);const o=new Set(["superTrack","compositeTrack","container","view"]);if(!l.some(d=>o.has(d))){if(!l.includes("bigDataUrl"))throw new Error(`Track ${c} is missing required key "bigDataUrl"`);if(!l.includes("type")&&!Object.keys(this.settings(c)).includes("type"))throw new Error(`Neither track ${c} nor any of its parent tracks have the required key "type"`)}let i=c;do i=(t=this.data[i])==null?void 0:t.parent,i&&([i]=i.split(" "));while(i);const e=this.data[c];e&&(this.data[c]=e)}}settings(t){var c;if(!this.data[t])throw new Error(`Track ${t} does not exist`);const s=[t];let l=t;do l=(c=this.data[l])==null?void 0:c.parent,l&&s.push(l);while(l);const o={};s.reverse();for(const i of s){const e=this.data[i];if(e)for(const[d,m]of Object.entries(e))o[d]=m}return o}}class I extends q{validate(t=["genome","trackDb"]){if(this.nameKey!=="genome")throw new Error('Genomes file must begin with a line like "genome <genome_name>"');for(const[c,s]of Object.entries(this.data))L(s,t,`genome ${c}`)}}class N extends k{validate(){L(this,["hub","shortLabel","longLabel","genomesFile","email"],"Hub file")}}class G{constructor(t){const[c,s,...l]=t.trimEnd().split(/(?:[\t ]*\r?\n){2,}/);this.hubData=new k(c),this.validateHub(),this.genome=new k(s),this.validateGenomeSection(),this.tracks=new B(l.join(`

`),{skipValidation:!1})}validateHub(){if(this.hubData.nameKey!=="hub")throw new Error('Hub file must begin with a line like "hub <hub_name>"');L(this.hubData,["hub","shortLabel","longLabel","email"])}validateGenomeSection(){if(this.genome.nameKey!=="genome")throw new Error('Genomes file must begin with a line like "genome <genome_name>"')}}var H=O();async function V(n){const t=await U.openLocation(n).readFile("utf8");return new I(t)}async function R(n){const t=await U.openLocation(n).readFile("utf8");return new B(t)}function C(n,t){return{uri:new URL(n,new URL(t.uri,t.baseUri)).href,locationType:"UriLocation"}}function D(n,t,c){return C(n||t,c)}function g(n,t){return n?{uri:n,locationType:"LocalPath"}:{uri:t,locationType:"UriLocation"}}function b(n,t){return new URL(n,t).href}function S({trackDb:n,trackDbLoc:t,assemblyName:c,sequenceAdapter:s,baseUrl:l}){const o=new Set(["superTrack","compositeTrack","container","view"]);return Object.entries(n.data).map(([i,e])=>{var d;const{data:m}=e;if(!Object.keys(m).some(a=>o.has(a))){const a=[];let h=i;do h=((d=n.data[h])===null||d===void 0?void 0:d.data.parent)||"",h&&(h=h.split(" ")[0],a.push(n.data[h]));while(h);return a.reverse(),{metadata:{...e.data,...e.data.html?{html:`<a href="${b(e.data.html,l)}">${e.data.html}</a>`}:{}},category:[e.data.group,...a.map(r=>r==null?void 0:r.data.group).filter(r=>!!r)].filter(r=>!!r),..._({track:e,trackDbLoc:t,trackDb:n,sequenceAdapter:s})}}}).filter(y.notEmpty).map(i=>({...i,trackId:`ucsc-trackhub-${y.objectHash(i)}`,assemblyNames:[c]}))}function _({track:n,trackDbLoc:t,trackDb:c,sequenceAdapter:s}){var l;const{data:o}=n,i=o.parent||"",e=o.bigDataUrl||"",d=o.bigDataIndex||"",m=o.type||((l=c.data[i])===null||l===void 0?void 0:l.data.type)||"",a=(o.shortLabel||"")+(e.includes("xeno")?" (xeno)":""),h=y.isUriLocation(t);let r=m.split(" ")[0]||"";r==="bam"&&e.toLowerCase().endsWith("cram")&&(r="cram");const u=h?C(e,t):g(e);return r==="bam"?{type:"AlignmentsTrack",name:a,description:o.longLabel,adapter:{type:"BamAdapter",bamLocation:u,index:{location:h?D(d,`${e}.bai`,t):g(d,`${e}.bai`)}}}:r==="cram"?{type:"AlignmentsTrack",name:a,description:o.longLabel,adapter:{type:"CramAdapter",cramLocation:u,craiLocation:h?D(d,`${e}.crai`,t):g(d,`${e}.crai`),sequenceAdapter:s}}:r==="bigWig"?{type:"QuantitativeTrack",name:a,description:o.longLabel,adapter:{type:"BigWigAdapter",bigWigLocation:u}}:r.startsWith("big")?{type:"FeatureTrack",name:a,description:o.longLabel,adapter:{type:"BigBedAdapter",bigBedLocation:u}}:r==="vcfTabix"?{type:"VariantTrack",name:a,description:o.longLabel,adapter:{type:"VcfTabixAdapter",vcfGzLocation:u,index:{location:h?D(d,`${e}.tbi`,t):g(d,`${e}.tbi`)}}}:r==="hic"?{type:"HicTrack",name:a,description:o.longLabel,adapter:{type:"HicAdapter",hicLocation:u}}:W.generateUnknownTrackConf(a,r)}async function Y(n){var t;const{pluginManager:c}=y.getEnv(n),s=y.getSession(n),l=[];try{const o=w.getConf(n,"hubTxtLocation"),i=await U.openLocation(o).readFile("utf8"),e=b(o.uri,o.baseUri),{assemblyManager:d}=s;if(i.includes("useOneFile on")){const m=new G(i),{genome:a,tracks:h}=m,r=a.name,u=a.data.description;d.get(r)||s.addSessionAssembly({name:r,displayName:u,sequence:{type:"ReferenceSequenceTrack",metadata:{...a.data,...a.data.htmlPath?{htmlPath:`<a href="${b(a.data.htmlPath,e)}">${a.data.htmlPath}</a>`}:{}},trackId:`${r}-${H.nanoid()}`,adapter:{type:"TwoBitAdapter",twoBitLocation:{uri:b(a.data.twoBitPath,e)},chromSizesLocation:{uri:b(a.data.chromSizes,e)}}},...a.data.chromAliasBb?{refNameAliases:{adapter:{type:"BigBedAdapter",uri:b(a.data.chromAliasBb,e)}}}:{}});const f=d.get(r),v=w.getConf(f,["sequence","adapter"]),$=S({trackDb:h,trackDbLoc:o,assemblyName:r,sequenceAdapter:v,baseUrl:e});n.addTrackConfs($),c.evaluateExtensionPoint("LaunchView-LinearGenomeView",{session:s,assembly:r,tracklist:!0,loc:a.data.defaultPos})}else{const m=new N(i).data.genomesFile;if(!m)throw new Error("genomesFile not found on hub");const a=b(o.uri,o.baseUri),h=a?{uri:b(m,a),locationType:"UriLocation"}:{localPath:m,locationType:"LocalPathLocation"},r=await V(h),u={};for(const[p,T]of Object.entries(r.data)){const A=w.getConf(n,"assemblyNames");if(A.length>0&&!A.includes(p))continue;const x=d.get(p);if(!x){l.push(p);continue}const E=T.data.trackDb;if(!E)throw new Error("genomesFile not found on hub");const P=new URL(m,a),j=a?{uri:new URL(E,P).href,locationType:"UriLocation"}:{localPath:E,locationType:"LocalPathLocation"},z=await R(j),F=w.getConf(x,["sequence","adapter"]),K=S({trackDb:z,trackDbLoc:j,assemblyName:p,sequenceAdapter:F,baseUrl:a});n.addTrackConfs(K),u[p]=K.length}const f=Object.entries(u),v=f.length?`Loaded data from these assemblies: ${f.map(([p,T])=>`${p} (${T} tracks)`).join(", ")}`:"",$=l.length?`Skipped data from these assemblies: ${l.join(", ")}`:"";s.notify([v,$].filter(p=>!!p).join(". "),"success")}}catch(o){console.error(o),s.notifyError(`${w.getConf(n,"name")}: "${o}"`,o),(t=s.breakConnection)===null||t===void 0||t.call(s,n.configuration)}}export{Y as doConnect};
