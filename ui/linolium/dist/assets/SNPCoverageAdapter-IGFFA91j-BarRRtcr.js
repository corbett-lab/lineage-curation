import{e as j}from"./index-Bp4pXTEU-Cipcrd2k.js";import{o as F}from"./rxjs-euq-mp90-DvajfGj-.js";import{m as _}from"./simpleFeature-CxppDrI6-CpRiIJat.js";import{bN as N,$ as R,a0 as B,O as E,u as k,bs as M}from"./JBrowsePanel-CjeUdi3D-Dhrr89W5.js";import{E as I,N as P}from"./getMethBins-DIAFukER-L3fr6GmJ.js";import"./taxonium-component.es-D8UFPkMd.js";import"./index-Bwk-R6QR.js";function T({feature:t,bins:n,region:e}){const o=t.get("start"),s=t.get("end"),r=t.get("strand"),p=e.end-e.start;for(let i=o;i<s+1;i++){const a=i-e.start;a>=0&&a<p&&(n[a]===void 0&&(n[a]={depth:0,readsCounted:0,ref:{probabilities:[],entryDepth:0,"-1":0,0:0,1:0},snps:{},mods:{},nonmods:{},delskips:{},noncov:{}}),i!==s&&(n[a].depth++,n[a].readsCounted++,n[a].ref.entryDepth++,n[a].ref[r]++))}}function G(t){return $(t.type)?1:t.length}function $(t){return t==="softclip"||t==="hardclip"||t==="insertion"}function C(t,n,e,o){let s=t[e][o];s===void 0&&(s=t[e][o]={entryDepth:0,probabilities:[],"-1":0,0:0,1:0}),s.entryDepth++,s[n]++}function w(t,n,e,o,s){let r=t[e][o];r===void 0&&(r=t[e][o]={entryDepth:0,probabilities:[],"-1":0,0:0,1:0}),r.entryDepth++,r.probabilities.push(s),r[n]++}function L({feature:t,region:n,bins:e,skipmap:o}){var s;const r=t.get("start"),p=t.get("strand"),i=(s=t.get("mismatches"))!==null&&s!==void 0?s:[];for(const a of i){const f=r+a.start,l=G(a),m=f+l;for(let d=f;d<f+l;d++){const c=d-n.start;if(c>=0&&c<e.length){const b=e[c],{base:u,altbase:g,type:h}=a,D=$(h);h==="deletion"||h==="skip"?(C(b,p,"delskips",h),b.depth--):D?C(b,p,"noncov",h):(C(b,p,"snps",u),b.ref.entryDepth--,b.ref[p]--,b.refbase=g)}}if(a.type==="skip"){const d=t.get("tags"),c=(d==null?void 0:d.XS)||(d==null?void 0:d.TS),b=d==null?void 0:d.ts,u=c==="+"?1:c==="-"?-1:(b==="+"?1:c==="-"?-1:0)*p,g=`${f}_${m}_${u}`;o[g]===void 0&&(o[g]={feature:t,start:f,end:m,strand:p,effectiveStrand:u,score:0}),o[g].score++}}}function V({feature:t,colorBy:n,region:e,bins:o,regionSequence:s}){var r,p,i;const a=t.get("start"),f=t.get("strand"),l=t.get("end"),m=(r=n==null?void 0:n.modifications)===null||r===void 0?void 0:r.twoColor,d=(p=n==null?void 0:n.modifications)===null||p===void 0?void 0:p.isolatedModification;(i=I(t))===null||i===void 0||i.forEach(({allProbs:c,prob:b,type:u},g)=>{if(d&&u!==d)return;const h=g+a-e.start;if(h>=0&&h<o.length&&g+a<l){o[h]===void 0&&(o[h]={depth:0,readsCounted:0,snps:{},ref:{probabilities:[],entryDepth:0,"-1":0,0:0,1:0},mods:{},nonmods:{},delskips:{},noncov:{}});const D=1-k.sum(c),v=o[h];v.refbase=s[h],m&&D>k.max(c)?w(v,f,"nonmods",`nonmod_${u}`,D):w(v,f,"mods",`mod_${u}`,b)}g++})}function W({feature:t,region:n,bins:e,regionSequence:o}){var s;const r=t.get("start"),p=t.get("end"),i=t.get("strand"),a=t.get("seq"),f=(s=t.get("mismatches"))!==null&&s!==void 0?s:[],l=o.toLowerCase();if(a){const m=M(t.get("CIGAR")),{methBins:d,methProbs:c}=P(t,m),b=f.filter(u=>u.type==="deletion");for(let u=0;u<p-r;u++){const g=u+r,h=l[g-n.start+1],D=l[g-n.start+2];if(h==="c"&&D==="g"){const v=e[g-n.start],y=e[g-n.start+1],x=d[u],O=d[u+1],q=c[u],A=c[u+1];x&&(q===void 0||q>.5)||O&&(A===void 0||A>.5)?(v&&(w(v,i,"mods","cpg_meth",q||0),v.ref.entryDepth--,v.ref[i]--),y&&(w(y,i,"mods","cpg_meth",A||0),y.ref.entryDepth--,y.ref[i]--)):(v&&(b.some(S=>k.doesIntersect2(g,g+1,S.start+r,S.start+r+S.length))||(w(v,i,"nonmods","cpg_unmeth",1-(q||0)),v.ref.entryDepth--,v.ref[i]--)),y&&(b.some(S=>k.doesIntersect2(g+1,g+2,S.start+r,S.start+r+S.length))||(w(y,i,"nonmods","cpg_unmeth",1-(A||0)),y.ref.entryDepth--,y.ref[i]--)))}}}}async function X({fetchSequence:t,features:n,region:e,opts:o}){const{stopToken:s,colorBy:r}=o,p={},i=[],a=Math.max(0,e.start-1),f=e.start-a;let l=performance.now();for(const m of n){if(performance.now()-l>400&&(E.checkStopToken(s),l=performance.now()),T({feature:m,bins:i,region:e}),(r==null?void 0:r.type)==="modifications"){const d=await t({...e,start:a,end:e.end+1})||"";V({feature:m,colorBy:r,bins:i,region:e,regionSequence:d.slice(f)})}else if((r==null?void 0:r.type)==="methylation"){const d=await t({...e,start:a,end:e.end+1})||"";W({feature:m,bins:i,region:e,regionSequence:d})}L({feature:m,skipmap:p,bins:i,region:e})}for(const m of i)m&&(m.mods=Object.fromEntries(Object.entries(m.mods).map(([d,c])=>[d,{...c,avgProbability:c.probabilities.length?k.sum(c.probabilities)/c.probabilities.length:void 0}])),m.nonmods=Object.fromEntries(Object.entries(m.nonmods).map(([d,c])=>[d,{...c,avgProbability:c.probabilities.length?k.sum(c.probabilities)/c.probabilities.length:void 0}])));return{bins:i,skipmap:p}}class Z extends j.BaseFeatureDataAdapter{async configure(){var n,e;const o=this.getConf("subadapter"),s=o.sequenceAdapter,r=await((n=this.getSubAdapter)===null||n===void 0?void 0:n.call(this,o)),p=s?await((e=this.getSubAdapter)===null||e===void 0?void 0:e.call(this,s)):void 0;if(!r)throw new Error("Failed to get subadapter");return{subadapter:r.dataAdapter,sequenceAdapter:p==null?void 0:p.dataAdapter}}async fetchSequence(n){const{sequenceAdapter:e}=await this.configure();if(e)return N(n,e)}getFeatures(n,e={}){return F.ObservableCreate(async o=>{const{subadapter:s}=await this.configure(),r=await R(s.getFeatures(n,e).pipe(B())),{bins:p,skipmap:i}=await X({features:r,region:n,opts:e,fetchSequence:f=>this.fetchSequence(f)});let a=0;for(const f of p){if(f){const l=n.start+a;o.next(new _({id:`${this.id}-${l}`,data:{score:f.depth,snpinfo:f,start:l,end:l+1,refName:n.refName}}))}a++}for(const[f,l]of Object.entries(i))o.next(new _({id:f,data:{type:"skip",start:l.start,end:l.end,strand:l.strand,score:l.score,effectiveStrand:l.effectiveStrand}}));o.complete()},e.stopToken)}async getMultiRegionFeatureDensityStats(n,e){const{subadapter:o}=await this.configure();return o.getMultiRegionFeatureDensityStats(n,e)}async getRefNames(n={}){const{subadapter:e}=await this.configure();return e.getRefNames(n)}}export{Z as default};
