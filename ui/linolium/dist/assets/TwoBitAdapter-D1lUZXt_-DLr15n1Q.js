import{r as b}from"./browser-BpRiKmO--zAOSyNoU.js";import{s as y,a1 as k}from"./JBrowsePanel-CjeUdi3D-Dhrr89W5.js";import{e as z}from"./index-Bp4pXTEU-Cipcrd2k.js";import{o as I}from"./rxjs-euq-mp90-DvajfGj-.js";import{m as U}from"./simpleFeature-CxppDrI6-CpRiIJat.js";import"./index-Bwk-R6QR.js";import"./taxonium-component.es-D8UFPkMd.js";const B=BigInt(32);function _(c,t,n){const s=+!!n,i=+!n;return BigInt(c.getInt32(t,n)*i+c.getInt32(t+4,n)*s)<<B|BigInt(c.getUint32(t,n)*s+c.getUint32(t+4,n)*i)}function v(c,t,n){const s=c.getUint32(t,n),i=c.getUint32(t+4,n),e=+!!n,a=+!n;return BigInt(s*a+i*e)<<B|BigInt(s*e+i*a)}"getBigInt64"in DataView||(DataView.prototype.getBigInt64=function(c,t){return _(this,c,t)});"getBigUint64"in DataView||(DataView.prototype.getBigUint64=function(c,t){return v(this,c,t)});const O=440477507,g=["T","C","A","G"],m=[];for(let c=0;c<256;c++)m.push(g[c>>6&3]+g[c>>4&3]+g[c>>2&3]+g[c&3]);const P=m.map(c=>c.toLowerCase());class q{constructor({filehandle:t,path:n}){if(t)this.filehandle=t;else if(n)this.filehandle=new b(n);else throw new Error("must supply path or filehandle")}async _detectEndianness(){const t=await this.filehandle.read(8,0),n=new DataView(t.buffer);if(n.getInt32(0,!0)===O)this.version=n.getInt32(0,!0);else throw new Error("not a 2bit file")}getHeader(){return this.headerP||(this.headerP=this._getHeader().catch(t=>{throw this.headerP=void 0,t})),this.headerP}async _getHeader(){await this._detectEndianness();const t=await this.filehandle.read(16,0),n=!0,s=new DataView(t.buffer,t.byteOffset,t.length);let i=0;const e=s.getInt32(i,n);if(i+=4,e!==440477507)throw new Error(`Wrong magic number ${e}`);const a=s.getInt32(i,n);i+=4;const o=s.getUint32(i,n);i+=4;const r=s.getUint32(i,n);return{version:a,magic:e,sequenceCount:o,reserved:r}}getIndex(){return this.indexP||(this.indexP=this._getIndex().catch(t=>{throw this.indexP=void 0,t})),this.indexP}async _getIndex(){const t=await this.getHeader(),n=8+t.sequenceCount*(257+(this.version===1?8:4)),s=await this.filehandle.read(n,8),i=!0,e=new DataView(s.buffer,s.byteOffset,s.length);let a=0;const o=e.getUint32(a,i);a+=4,a+=4;const r=[],l=new TextDecoder("utf8");for(let f=0;f<o;f++){const u=e.getUint8(a);a+=1;const h=l.decode(s.subarray(a,a+u));if(a+=u,t.version===1){const d=Number(e.getBigUint64(a,i));a+=8,r.push({offset:d,name:h})}else{const d=e.getUint32(a,i);a+=4,r.push({offset:d,name:h})}}return Object.fromEntries(r.map(({name:f,offset:u})=>[f,u]))}async getSequenceNames(){const t=await this.getIndex();return Object.keys(t)}async getSequenceSizes(){const t=await this.getIndex(),n=Object.keys(t),s=await Promise.all(Object.values(t).map(e=>this._getSequenceSize(e))),i={};for(const[e,a]of n.entries())i[a]=s[e];return i}async getSequenceSize(t){const n=(await this.getIndex())[t];return n?this._getSequenceSize(n):void 0}async _getSequenceSize(t){return this._record1(t).then(n=>n.dnaSize)}async _record1(t,n=8){const s=await this.filehandle.read(n,t),i=!0;let e=0;const a=new DataView(s.buffer,s.byteOffset,s.length),o=a.getUint32(e,i);e+=4;const r=a.getUint32(e,i);return e+=4,{dnaSize:o,nBlockCount:r}}async _record2(t,n){const s=await this.filehandle.read(n,t),i=!0;let e=0;const a=new DataView(s.buffer,s.byteOffset,s.length),o=a.getUint32(e,i);e+=4;const r=[];for(let f=0;f<o;f++){const u=a.getUint32(e,i);e+=4,r.push(u)}const l=[];for(let f=0;f<o;f++){const u=a.getUint32(e,i);e+=4,l.push(u)}return{maskBlockCount:a.getUint32(e,i),nBlockSizes:l,nBlockStarts:r}}async _record3(t,n){const s=await this.filehandle.read(n,t),i=!0;let e=0;const a=new DataView(s.buffer,s.byteOffset,s.length),o=a.getUint32(e,i);e+=4;const r=[];for(let u=0;u<o;u++){const h=a.getUint32(e,i);e+=4,r.push(h)}const l=[];for(let u=0;u<o;u++){const h=a.getUint32(e,i);e+=4,l.push(h)}const f=a.getInt32(e,i);return{maskBlockCount:o,maskBlockSizes:l,maskBlockStarts:r,reserved:f}}async _getSequenceRecord(t){const n=await this._record1(t),s=n.nBlockCount*8+8,i=await this._record2(t+4,s),e=i.maskBlockCount*8+8,a=await this._record3(t+4+s-4,e);return{dnaSize:n.dnaSize,nBlocks:{starts:i.nBlockStarts,sizes:i.nBlockSizes},maskBlocks:{starts:a.maskBlockStarts,sizes:a.maskBlockSizes},dnaPosition:t+4+s-4+e}}async getSequence(t,n=0,s=Number.POSITIVE_INFINITY){const i=(await this.getIndex())[t];if(!i)return;const e=await this._getSequenceRecord(i);if(n<0)throw new TypeError("regionStart cannot be less than 0");s>e.dnaSize&&(s=e.dnaSize);const a=this._getOverlappingBlocks(n,s,e.nBlocks.starts,e.nBlocks.sizes),o=this._getOverlappingBlocks(n,s,e.maskBlocks.starts,e.maskBlocks.sizes),r=Math.ceil((s-n)/4)+1,l=Math.floor(n/4),f=await this.filehandle.read(r,e.dnaPosition+l);let u="";for(let h=n;h<s;h+=1){for(;o.length>0&&o[0].end<=h;)o.shift();const d=o[0]&&o[0].start<=h&&o[0].end>h;if(a[0]&&h>=a[0].start&&h<a[0].end){const w=a.shift();for(;h<w.end&&h<s;h+=1)u+=d?"n":"N";h-=1}else{const w=Math.floor(h/4)-l,p=h%4,S=f[w];u+=d?P[S][p]:m[S][p]}}return u}_getOverlappingBlocks(t,n,s,i){let e,a;for(const[r,l]of s.entries()){const f=i[r];if(t>=l+f||n<=l){if(e!==void 0){a=r;break}}else e===void 0&&(e=r)}if(e===void 0)return[];a===void 0&&(a=s.length);const o=new Array(a-e);for(let r=e;r<a;r+=1)o[r-e]={start:s[r],end:s[r]+i[r],size:i[r]};return o}}class M extends z.BaseSequenceAdapter{async initChromSizes(){const t=y.readConfObject(this.config,"chromSizesLocation");if(t.uri!=="/path/to/default.chrom.sizes"&&t.uri!==""){const n=await k.openLocation(t,this.pluginManager).readFile("utf8");return Object.fromEntries(n.split(/\n|\r\n|\r/).filter(s=>!!s.trim()).map(s=>{const[i,e]=s.split("	");return[i,+e]}))}}async setupPre(){return{twobit:new q({filehandle:k.openLocation(this.getConf("twoBitLocation"),this.pluginManager)}),chromSizesData:await this.initChromSizes()}}async setup(){return this.setupP||(this.setupP=this.setupPre().catch(t=>{throw this.setupP=void 0,t})),this.setupP}async getRefNames(){const{chromSizesData:t,twobit:n}=await this.setup();return t?Object.keys(t):n.getSequenceNames()}async getRegions(){const{chromSizesData:t,twobit:n}=await this.setup();if(t)return Object.keys(t).map(s=>({refName:s,start:0,end:t[s]}));{const s=await n.getSequenceSizes();return Object.keys(s).map(i=>({refName:i,start:0,end:s[i]}))}}getFeatures({refName:t,start:n,end:s}){return I.ObservableCreate(async i=>{const{twobit:e}=await this.setup(),a=await e.getSequenceSize(t),o=a!==void 0?Math.min(a,s):s,r=await e.getSequence(t,n,o);r&&i.next(new U({id:`${t} ${n}-${o}`,data:{refName:t,start:n,end:o,seq:r}})),i.complete()})}}export{M as default};
