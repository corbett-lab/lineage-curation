import{f as v}from"./main-D1zX1xg0-CI_PM91Q.js";import{J as C,K as w}from"./util-DIF6WZFN-BRzR6C_J.js";import{e as F}from"./index-Bp4pXTEU-Cipcrd2k.js";import{u as p,a1 as b}from"./JBrowsePanel-CjeUdi3D-Dhrr89W5.js";import{x as y}from"./parseLineByLine-Be3SOOi9-j_LJE5Tt.js";import{o as T}from"./rxjs-euq-mp90-DvajfGj-.js";import"./index-Bwk-R6QR.js";import"./taxonium-component.es-D8UFPkMd.js";class x extends F.BaseFeatureDataAdapter{constructor(){super(...arguments),this.intervalTrees={}}async loadDataP(t){const e=this.getConf("bedLocation"),a=await p.fetchAndMaybeUnzip(b.openLocation(e,this.pluginManager),t),s=[],n={};y.parseLineByLine(a,r=>{if(r.startsWith("#"))s.push(r);else{const g=r.indexOf("	"),m=r.slice(0,g);n[m]||(n[m]=[]),n[m].push(r)}return!0},t==null?void 0:t.statusCallback);const c=s.join(`
`),i=this.getConf("autoSql"),o=new C({autoSql:i}),u=this.getConf("columnNames"),h=this.getConf("scoreColumn"),l=this.getConf("colRef"),d=this.getConf("colStart"),f=this.getConf("colEnd");return{header:c,features:n,parser:o,columnNames:u,scoreColumn:h,colRef:l,colStart:d,colEnd:f}}async loadData(t={}){return this.bedFeatures||(this.bedFeatures=this.loadDataP(t).catch(e=>{throw this.bedFeatures=void 0,e})),this.bedFeatures}async getRefNames(t={}){const{features:e}=await this.loadData(t);return Object.keys(e)}async getHeader(t={}){const{header:e}=await this.loadData(t);return e}async getNames(){const{header:t,columnNames:e}=await this.loadData();if(e.length)return e;const a=t.split(/\n|\r\n|\r/).filter(s=>!!s).at(-1);return a!=null&&a.includes("	")?a.slice(1).split("	").map(s=>s.trim()):void 0}async loadFeatureIntervalTreeHelper(t){const{colRef:e,colStart:a,colEnd:s,features:n,parser:c,scoreColumn:i}=await this.loadData(),o=n[t];if(!o)return;const u=await this.getNames(),h=new v;for(let l=0;l<o.length;l++){const d=o[l],f=`${this.id}-${t}-${l}`,r=new p.SimpleFeature(w({line:d,colRef:e,colStart:a,colEnd:s,scoreColumn:i,parser:c,uniqueId:f,names:u}));h.insert([r.get("start"),r.get("end")],r)}return h}async loadFeatureIntervalTree(t){return this.intervalTrees[t]||(this.intervalTrees[t]=this.loadFeatureIntervalTreeHelper(t).catch(e=>{throw this.intervalTrees[t]=void 0,e})),this.intervalTrees[t]}getFeatures(t,e={}){return T.ObservableCreate(async a=>{const{start:s,end:n,refName:c}=t,i=await this.loadFeatureIntervalTree(c),o=i==null?void 0:i.search([s,n]);if(o)for(const u of o)a.next(u);a.complete()},e.stopToken)}}x.capabilities=["getFeatures","getRefNames"];export{x as default};
