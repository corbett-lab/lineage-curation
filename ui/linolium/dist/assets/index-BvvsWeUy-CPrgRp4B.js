import{bt as P}from"./JBrowsePanel-CjeUdi3D-Dhrr89W5.js";function O(o,i,e){const r=i.split("	"),t={};let n=0;if(o.includes("GT")){const l=o.split(":");if(l.length===1)for(const a of e)t[a]=r[n++];else{const a=l.indexOf("GT");if(a===0)for(const s of e){const p=r[n++],c=p.indexOf(":");t[s]=c!==-1?p.slice(0,c):p}else for(const s of e){const p=r[n++].split(":");t[s]=p[a]}}}return t}function C(o){const i=[];let e="",r=!1,t=!1;for(const n of o)n==='"'?(r=!r,e+=n):n==="["?(t=!0,e+=n):n==="]"?(t=!1,e+=n):n===","&&!r&&!t?(i.push(e.trim()),e=""):e+=n;return e&&i.push(e.trim()),i}function L(o,i){const e=o.indexOf(i);return[o.slice(0,e),o.slice(e+1)]}function w(o){const i=o.replace(/^<|>$/g,"");return Object.fromEntries(C(i).map(e=>{const[r,t]=L(e,"=");return t&&t.startsWith("[")&&t.endsWith("]")?[r,t.slice(1,-1).split(",").map(n=>n.trim())]:t&&t.startsWith('"')&&t.endsWith('"')?[r,t.slice(1,-1)]:[r,t==null?void 0:t.replaceAll(/^"|"$/g,"")]}))}const b={InfoFields:{AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},GenotypeFields:{AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},AltTypes:{DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},FilterTypes:{PASS:{Description:"Passed all filters"}}};function G(o){try{return decodeURIComponent(o)}catch{return o}}class Q{constructor({header:i="",strict:e=!0}){if(!i.length)throw new Error("empty header received");const r=i.split(/[\r\n]+/).filter(Boolean);if(!r.length)throw new Error("no non-empty header lines specified");this.strict=e,this.metadata=JSON.parse(JSON.stringify({INFO:b.InfoFields,FORMAT:b.GenotypeFields,ALT:b.AltTypes,FILTER:b.FilterTypes}));let t;if(r.forEach(s=>{if(s.startsWith("#"))s.startsWith("##")?this.parseMetadata(s):t=s;else throw new Error(`Bad line in header:
${s}`)}),!t)throw new Error("No format line found in header");const n=t.trim().split("	"),l=n.slice(0,8),a=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(n.length<8)throw new Error(`VCF header missing columns:
${t}`);if(l.length!==a.length||!l.every((s,p)=>s===a[p]))throw new Error(`VCF column headers not correct:
${t}`);this.samples=n.slice(9)}parseSamples(i,e){const r={};if(i){const t=e.split("	"),n=i.split(":"),l=n.map(a=>{const s=this.getMetadata("FORMAT",a,"Type");return s==="Integer"||s==="Float"});for(let a=0;a<this.samples.length;a++){const s=this.samples[a];r[s]={};const p=t[a].split(":");for(let c=0;c<p.length;c++){const m=p[c];r[s][n[c]]=m===""||m==="."?void 0:m.split(",").map(d=>d==="."?void 0:l[c]?+d:d)}}}return r}parseMetadata(i){const e=/^##(.+?)=(.*)/.exec(i.trim());if(!e)throw new Error(`Line is not a valid metadata line: ${i}`);const[r,t]=e.slice(1,3),n=r;if(t!=null&&t.startsWith("<")){n in this.metadata||(this.metadata[n]={});const[l,a]=this.parseStructuredMetaVal(t);l?this.metadata[n][l]=a:this.metadata[n]=a}else this.metadata[n]=t}parseStructuredMetaVal(i){const e=w(i),r=e.ID;return delete e.ID,"Number"in e&&(Number.isNaN(Number(e.Number))||(e.Number=Number(e.Number))),[r,e]}getMetadata(...i){let e=this.metadata;for(const r of i)if(e=e[r],!e)return e;return e}parseLine(i){var e;let r=0;for(let D=0;r<i.length&&(i[r]==="	"&&(D+=1),D!==9);r+=1);const t=i.slice(0,r).split("	"),n=i.slice(r+1),[l,a,s,p,c,m,d]=t,g=l,I=+a,S=s==="."?void 0:s.split(";"),A=p,E=c==="."?void 0:c.split(","),v=m==="."?void 0:+m,h=d==="."?void 0:d.split(";"),R=t[8];if(this.strict&&!t[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");const F=(e=t[7])==null?void 0:e.includes("%"),M=t[7]===void 0||t[7]==="."?{}:Object.fromEntries(t[7].split(";").map(D=>{const[f,T]=D.split("="),y=T==null?void 0:T.split(",").map(u=>u==="."?void 0:u).map(u=>u&&F?G(u):u),N=this.getMetadata("INFO",f,"Type");return N==="Integer"||N==="Float"?[f,y==null?void 0:y.map(u=>u===void 0?void 0:Number(u))]:N==="Flag"?[f,!0]:[f,y??!0]}));return{CHROM:g,POS:I,ALT:E,INFO:M,REF:A,FILTER:h&&h.length===1&&h[0]==="PASS"?"PASS":h,ID:S,QUAL:v,FORMAT:R,SAMPLES:()=>this.parseSamples(t[8]??"",n),GENOTYPES:()=>O(t[8]??"",n,this.samples)}}}function V(o,i){const{REF:e="",ALT:r,POS:t,CHROM:n,ID:l}=o,a=t-1,[s,p]=P(e,r,i);return{refName:n,start:a,end:q(o),description:p,type:s,name:l==null?void 0:l.join(",")}}function q(o){const{POS:i,REF:e="",ALT:r}=o,t=r==null?void 0:r.includes("<TRA>"),n=i-1;if(r!=null&&r.some(l=>l.includes("<"))){const l=o.INFO;if(l.END&&!t)return+l.END[0]}return n+e.length}class k{constructor(i){this.variant=i.variant,this.parser=i.parser,this.data=V(this.variant,this.parser),this._id=i.id}get(i){var e;return i==="samples"?this.variant.SAMPLES():i==="genotypes"?this.variant.GENOTYPES():(e=this.data[i])!==null&&e!==void 0?e:this.variant[i]}parent(){}children(){}id(){return this._id}toJSON(){const{SAMPLES:i,GENOTYPES:e,...r}=this.variant;return{uniqueId:this._id,...r,...this.data,samples:this.variant.SAMPLES()}}}export{Q,k as q};
